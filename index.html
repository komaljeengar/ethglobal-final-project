<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>dr.H</title>
    <meta name="description" content="Dr. Hedera" />
    <meta name="author" content=" " />

    <meta property="og:title" content="Dr. Hedera" />
    <meta property="og:description" content="Dr. Hedera" />
    <meta property="og:type" content="website" />
  

    
    
    <!-- Prevent extension script conflicts -->
    <script>
      // Protect React context from extension interference
      (function() {
        // Store original React if it exists
        let originalReact = window.React;
        let originalReactDOM = window.ReactDOM;
        
        // Create a protected React namespace
        const protectedReact = {
          createContext: originalReact?.createContext || function() {},
          useState: originalReact?.useState || function() {},
          useEffect: originalReact?.useEffect || function() {},
          useLayoutEffect: originalReact?.useLayoutEffect || function() {},
          useContext: originalReact?.useContext || function() {},
          useReducer: originalReact?.useReducer || function() {},
          useMemo: originalReact?.useMemo || function() {},
          useCallback: originalReact?.useCallback || function() {},
          useRef: originalReact?.useRef || function() {},
          forwardRef: originalReact?.forwardRef || function() {},
          memo: originalReact?.memo || function() {},
          createElement: originalReact?.createElement || function() {},
          Fragment: originalReact?.Fragment || function() {},
          Component: originalReact?.Component || function() {}
        };
        
        // Prevent extensions from overriding React
        Object.defineProperty(window, 'React', {
          get: function() {
            return protectedReact;
          },
          set: function(value) {
            if (value && typeof value === 'object') {
              // Only update if it's a valid React object
              if (value.createContext && value.useState && value.useEffect) {
                originalReact = value;
                // Update protected version with new React
                Object.assign(protectedReact, value);
              }
            }
          },
          configurable: false
        });
        
        // Protect ReactDOM as well
        if (originalReactDOM) {
          Object.defineProperty(window, 'ReactDOM', {
            get: function() {
              return originalReactDOM;
            },
            set: function(value) {
              if (value && value.render && value.createRoot) {
                originalReactDOM = value;
              }
            },
            configurable: false
          });
        }
        
        // Enhanced error boundary for extension conflicts
        window.addEventListener('error', function(event) {
          if (event.error && event.error.message) {
            const errorMsg = event.error.message;
            if (errorMsg.includes('createContext') || 
                errorMsg.includes('useLayoutEffect') ||
                errorMsg.includes('Cannot read properties') ||
                errorMsg.includes('Cannot destructure') ||
                errorMsg.includes('content.js') ||
                errorMsg.includes('selection.js') ||
                errorMsg.includes('knowee') ||
                errorMsg.includes('intermediate value') ||
                errorMsg.includes('is null')) {
              console.warn('Extension conflict detected, ignoring error:', errorMsg);
              event.preventDefault();
              return false;
            }
          }
        });
        
        // Handle unhandled promise rejections
        window.addEventListener('unhandledrejection', function(event) {
          if (event.reason && event.reason.message) {
            const errorMsg = event.reason.message;
            if (errorMsg.includes('createContext') || 
                errorMsg.includes('useLayoutEffect') ||
                errorMsg.includes('Cannot read properties') ||
                errorMsg.includes('Cannot destructure') ||
                errorMsg.includes('content.js') ||
                errorMsg.includes('selection.js') ||
                errorMsg.includes('intermediate value') ||
                errorMsg.includes('is null')) {
              console.warn('Extension conflict in promise, ignoring:', errorMsg);
              event.preventDefault();
              return false;
            }
          }
        });
        
        // Prevent extension scripts from running in our context
        const observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            mutation.addedNodes.forEach(function(node) {
              if (node.tagName === 'SCRIPT') {
                // Block extension scripts by src
                if (node.src && (node.src.includes('content.js') || 
                    node.src.includes('selection.js') || 
                    node.src.includes('knowee') || 
                    node.src.includes('extension'))) {
                  console.warn('Blocked extension script injection:', node.src);
                  node.remove();
                  return;
                }
                
                // Block extension scripts by content
                if (node.textContent && (
                    node.textContent.includes('knowee') ||
                    node.textContent.includes('KNOWEE') ||
                    node.textContent.includes('FloatTool') ||
                    node.textContent.includes('messageSubscribe'))) {
                  console.warn('Blocked extension script by content');
                  node.remove();
                  return;
                }
              }
            });
          });
        });
        
        observer.observe(document, {
          childList: true,
          subtree: true
        });
        
        // Additional protection: Override console methods to filter extension logs
        const originalConsoleWarn = console.warn;
        const originalConsoleError = console.error;
        
        console.warn = function(...args) {
          const message = args.join(' ');
          if (!message.includes('content.js') && 
              !message.includes('selection.js') && 
              !message.includes('knowee')) {
            originalConsoleWarn.apply(console, args);
          }
        };
        
        console.error = function(...args) {
          const message = args.join(' ');
          if (!message.includes('content.js') && 
              !message.includes('selection.js') && 
              !message.includes('knowee')) {
            originalConsoleError.apply(console, args);
          }
        };
        
        // Additional protection: Override common extension patterns
        const originalConsoleLog = console.log;
        console.log = function(...args) {
          const message = args.join(' ');
          if (!message.includes('content.js') && 
              !message.includes('selection.js') && 
              !message.includes('knowee') &&
              !message.includes('FloatTool') &&
              !message.includes('messageSubscribe')) {
            originalConsoleLog.apply(console, args);
          }
        };
        
        // Prevent extension from accessing critical objects
        const protectedObjects = ['React', 'ReactDOM', 'Vue', 'Angular'];
        protectedObjects.forEach(objName => {
          if (window[objName]) {
            const original = window[objName];
            Object.freeze(window[objName]);
            Object.seal(window[objName]);
          }
        });
        
        // Block extension message passing
        const originalPostMessage = window.postMessage;
        window.postMessage = function(message, targetOrigin, transfer) {
          if (typeof message === 'string' && (
              message.includes('knowee') || 
              message.includes('KNOWEE') ||
              message.includes('extension'))) {
            console.warn('Blocked extension postMessage:', message);
            return;
          }
          originalPostMessage.call(this, message, targetOrigin, transfer);
        };
        
        // Block extension event listeners
        const originalAddEventListener = EventTarget.prototype.addEventListener;
        EventTarget.prototype.addEventListener = function(type, listener, options) {
          if (typeof listener === 'function' && listener.toString().includes('content.js')) {
            console.warn('Blocked extension event listener');
            return;
          }
          originalAddEventListener.call(this, type, listener, options);
        };
        
        console.log('Enhanced extension protection initialized');
      })();
    </script>
  </head>

  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
