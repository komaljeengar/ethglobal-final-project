<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>dr.H</title>
    <meta name="description" content="Dr. Hedera" />
    <meta name="author" content=" " />

    <meta property="og:title" content="Dr. Hedera" />
    <meta property="og:description" content="Dr. Hedera" />
    <meta property="og:type" content="website" />

    <!-- Content Security Policy to prevent extension conflicts -->
    <meta http-equiv="Content-Security-Policy" content="
      default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob:;
      script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdn.jsdelivr.net https://unpkg.com;
      style-src 'self' 'unsafe-inline' https://fonts.googleapis.com data:;
      font-src 'self' https://fonts.gstatic.com data: blob:;
      img-src 'self' data: blob: https:;
      connect-src 'self' https: wss:;
      frame-src 'none';
      object-src 'none';
      base-uri 'self';
      form-action 'self';
    ">
    
    <!-- Prevent extension script conflicts -->
    <script>
      // Protect React context from extension interference
      (function() {
        // Store original React if it exists
        let originalReact = window.React;
        let originalReactDOM = window.ReactDOM;
        
        // Create a protected React namespace
        const protectedReact = {
          createContext: originalReact?.createContext || function() {},
          useState: originalReact?.useState || function() {},
          useEffect: originalReact?.useEffect || function() {},
          useLayoutEffect: originalReact?.useLayoutEffect || function() {},
          useContext: originalReact?.useContext || function() {},
          useReducer: originalReact?.useReducer || function() {},
          useMemo: originalReact?.useMemo || function() {},
          useCallback: originalReact?.useCallback || function() {},
          useRef: originalReact?.useRef || function() {},
          forwardRef: originalReact?.forwardRef || function() {},
          memo: originalReact?.memo || function() {},
          createElement: originalReact?.createElement || function() {},
          Fragment: originalReact?.Fragment || function() {},
          Component: originalReact?.Component || function() {}
        };
        
        // Prevent extensions from overriding React
        Object.defineProperty(window, 'React', {
          get: function() {
            return protectedReact;
          },
          set: function(value) {
            if (value && typeof value === 'object') {
              // Only update if it's a valid React object
              if (value.createContext && value.useState && value.useEffect) {
                originalReact = value;
                // Update protected version with new React
                Object.assign(protectedReact, value);
              }
            }
          },
          configurable: false
        });
        
        // Protect ReactDOM as well
        if (originalReactDOM) {
          Object.defineProperty(window, 'ReactDOM', {
            get: function() {
              return originalReactDOM;
            },
            set: function(value) {
              if (value && value.render && value.createRoot) {
                originalReactDOM = value;
              }
            },
            configurable: false
          });
        }
        
        // Enhanced error boundary for extension conflicts
        window.addEventListener('error', function(event) {
          if (event.error && event.error.message) {
            const errorMsg = event.error.message;
            if (errorMsg.includes('createContext') || 
                errorMsg.includes('useLayoutEffect') ||
                errorMsg.includes('Cannot read properties') ||
                errorMsg.includes('Cannot destructure') ||
                errorMsg.includes('content.js') ||
                errorMsg.includes('selection.js') ||
                errorMsg.includes('knowee') ||
                errorMsg.includes('intermediate value') ||
                errorMsg.includes('is null') ||
                errorMsg.includes('m @ content.js:519') ||
                event.filename && event.filename.includes('content.js')) {
              console.warn('Extension conflict detected, ignoring error:', errorMsg);
              event.preventDefault();
              event.stopPropagation();
              return false;
            }
          }
        });
        
        // Handle unhandled promise rejections
        window.addEventListener('unhandledrejection', function(event) {
          if (event.reason && event.reason.message) {
            const errorMsg = event.reason.message;
            if (errorMsg.includes('createContext') || 
                errorMsg.includes('useLayoutEffect') ||
                errorMsg.includes('Cannot read properties') ||
                errorMsg.includes('Cannot destructure') ||
                errorMsg.includes('content.js') ||
                errorMsg.includes('selection.js') ||
                errorMsg.includes('intermediate value') ||
                errorMsg.includes('is null') ||
                errorMsg.includes('m @ content.js:519')) {
              console.warn('Extension conflict in promise, ignoring:', errorMsg);
              event.preventDefault();
              event.stopPropagation();
              return false;
            }
          }
        });
        
        // More aggressive extension script blocking
        const observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            mutation.addedNodes.forEach(function(node) {
              if (node.tagName === 'SCRIPT') {
                // Block extension scripts by src
                if (node.src && (node.src.includes('content.js') || 
                    node.src.includes('selection.js') || 
                    node.src.includes('knowee') || 
                    node.src.includes('extension'))) {
                  console.warn('Blocked extension script injection:', node.src);
                  node.remove();
                  return;
                }
                
                // Block extension scripts by content
                if (node.textContent && (
                    node.textContent.includes('knowee') ||
                    node.textContent.includes('KNOWEE') ||
                    node.textContent.includes('FloatTool') ||
                    node.textContent.includes('messageSubscribe') ||
                    node.textContent.includes('localPdfTips') ||
                    node.textContent.includes('getUserInfo') ||
                    node.textContent.includes('getTokenAsync'))) {
                  console.warn('Blocked extension script by content');
                  node.remove();
                  return;
                }
              }
            });
          });
        });
        
        // Block extension scripts that are already loaded
        const existingScripts = document.querySelectorAll('script');
        existingScripts.forEach(function(script) {
          if (script.src && (script.src.includes('content.js') || 
              script.src.includes('selection.js') || 
              script.src.includes('knowee'))) {
            console.warn('Removing existing extension script:', script.src);
            script.remove();
          }
        });
        
        observer.observe(document, {
          childList: true,
          subtree: true
        });
        
        // Filter console logs to reduce extension noise (less aggressive)
        const originalConsoleLog = console.log;
        const originalConsoleWarn = console.warn;
        const originalConsoleError = console.error;
        
        const shouldFilterMessage = (message) => {
          return message.includes('content.js') || 
                 message.includes('selection.js') || 
                 message.includes('knowee') ||
                 message.includes('FloatTool') ||
                 message.includes('messageSubscribe') ||
                 message.includes('KNOWEE');
        };
        
        console.log = function(...args) {
          const message = args.join(' ');
          if (!shouldFilterMessage(message)) {
            originalConsoleLog.apply(console, args);
          }
        };
        
        console.warn = function(...args) {
          const message = args.join(' ');
          if (!shouldFilterMessage(message)) {
            originalConsoleWarn.apply(console, args);
          }
        };
        
        console.error = function(...args) {
          const message = args.join(' ');
          if (!shouldFilterMessage(message)) {
            originalConsoleError.apply(console, args);
          }
        };
        
        // Light protection for critical objects (less aggressive)
        const protectedObjects = ['React', 'ReactDOM'];
        protectedObjects.forEach(objName => {
          if (window[objName]) {
            // Only seal, don't freeze to allow React updates
            try {
              Object.seal(window[objName]);
            } catch (e) {
              // Ignore if already sealed
            }
          }
        });
        
        // Light blocking of extension message passing (only for known extension patterns)
        const originalPostMessage = window.postMessage;
        window.postMessage = function(message, targetOrigin, transfer) {
          if (typeof message === 'string' && message.includes('knowee')) {
            console.warn('Blocked extension postMessage:', message);
            return;
          }
          originalPostMessage.call(this, message, targetOrigin, transfer);
        };
        
        // Light blocking of extension event listeners (only for content.js)
        const originalAddEventListener = EventTarget.prototype.addEventListener;
        EventTarget.prototype.addEventListener = function(type, listener, options) {
          if (typeof listener === 'function' && 
              listener.toString().includes('content.js') &&
              listener.toString().includes('knowee')) {
            console.warn('Blocked extension event listener');
            return;
          }
          originalAddEventListener.call(this, type, listener, options);
        };
        
        // Additional error suppression for extension conflicts
        const originalError = console.error;
        console.error = function(...args) {
          const message = args.join(' ');
          if (message.includes('content.js:519') || 
              message.includes('Cannot destructure') ||
              message.includes('intermediate value') ||
              message.includes('selection.js') ||
              message.includes('knowee')) {
            // Suppress extension errors
            return;
          }
          originalError.apply(console, args);
        };
        
        // Override Promise to catch extension promise rejections
        const originalPromise = window.Promise;
        window.Promise = function(executor) {
          return new originalPromise(function(resolve, reject) {
            const wrappedReject = function(reason) {
              if (reason && reason.message && 
                  (reason.message.includes('Cannot destructure') ||
                   reason.message.includes('intermediate value') ||
                   reason.message.includes('content.js'))) {
                console.warn('Suppressed extension promise rejection:', reason.message);
                return;
              }
              reject(reason);
            };
            executor(resolve, wrappedReject);
          });
        };
        
        // Copy static methods from original Promise
        Object.setPrototypeOf(window.Promise, originalPromise);
        Object.defineProperty(window.Promise, 'resolve', { value: originalPromise.resolve });
        Object.defineProperty(window.Promise, 'reject', { value: originalPromise.reject });
        Object.defineProperty(window.Promise, 'all', { value: originalPromise.all });
        Object.defineProperty(window.Promise, 'race', { value: originalPromise.race });
        
        console.log('Enhanced extension protection initialized');
      })();
    </script>
  </head>

  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
